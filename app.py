# coding: utf-8
import uuid
from flask import Flask, request, redirect, flash
from flask_cqlalchemy import CQLAlchemy
import os
from datetime import datetime
from werkzeug.utils import secure_filename
import tensorflow as tf
from PIL import Image
import numpy as np
from skimage.color import rgb2gray
from skimage.filters import threshold_sauvola



app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = "./uploads"
app.config['CASSANDRA_HOSTS'] = ['db']
app.config['CASSANDRA_KEYSPACE'] = "cqlengine"
app.config['SECRET_KEY'] = "Your_secret_string"
checkpoint_path = "model/cp.ckpt"
db = CQLAlchemy(app)


# db.sync_db()
# save and restore model
def create_model():
    model = tf.keras.models.Sequential([
        tf.keras.layers.Dense(512, activation=tf.nn.relu, input_shape=(784,)),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(10, activation=tf.nn.softmax)
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(),
                  loss=tf.keras.losses.sparse_categorical_crossentropy,
                  metrics=['accuracy'])

    return model

# define and set images size
def load_image(file):
    im = Image.open(file)
    resized_im = im.resize((28, 28))

    pix = np.array(resized_im)
    img = rgb2gray(pix)
    window_size = 25
    thresh_sauvola = threshold_sauvola(img, window_size=window_size)
    binary_sauvola = img > thresh_sauvola
    return binary_sauvola.reshape(-1, 28 * 28)

# set figure in db
class Picture(db.Model):
    uid = db.columns.UUID(primary_key=True, default=uuid.uuid4)
    name = db.columns.Text(required=False)
    path = db.columns.Text(required=False)
    created_at = db.columns.DateTime(required=False)
    data = db.columns.Blob(required=True)
    result = db.columns.SmallInt(required=True)


UPLOAD_FOLDER = './uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
SUCCESS_STRING = '''
<!doctype html>
<title>Test Result</title>
<h1>Your result for picture {} is </h1>
<p> {} </p>
'''
TRAIN_STRING = '''
<!doctype html>
<title>Train Complete</title>
<h1>Train Complete</h1>
'''
GET_STRING = '''
<!doctype html>
<title>Upload new File</title>
<h1>Upload new File</h1>
<form method=post enctype=multipart/form-data>
    <p><input type=file name=file>
    <input type=submit value=Upload>
</form>
    '''


def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# set the web
@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        # check if the post request has the file part
        if 'file' not in request.files:
            flash('No file part')
            return redirect(request.url)
        img = request.files['file']
        # if user does not select file, browser also
        # submit a empty part without filename
        if img.filename == '':
            flash('No selected file')
            return redirect(request.url)
        if img and allowed_file(img.filename):
            # save image to local
            img.read()
            filename = secure_filename(img.filename)
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            img.save(file_path)

            # get ans generated by tf
            im = load_image(img)

            model = create_model()
            model.load_weights(checkpoint_path)
            ans = np.argmax(model.predict(im))

            # generate timestamp and save to Cassandra
            db.sync_db()  # 建表
            data = bytearray(im)  # 把图片变成byte数组
            Picture.create(
                name=filename,
                path=file_path,
                created_at=datetime.now(),
                data=data,
                result=ans,
            )
            # return ans
            return SUCCESS_STRING.format(filename, ans)
    return GET_STRING


@app.route('/train', methods=['GET', 'POST'])
def train():
    # Create checkpoint callback
    cp_callback = tf.keras.callbacks.ModelCheckpoint(checkpoint_path,
                                                     save_weights_only=True,
                                                     verbose=1)
    mnist = tf.keras.datasets.mnist

    (x_train, y_train), (x_test, y_test) = mnist.load_data()
    x_train, x_test = x_train.reshape(-1, 28 * 28) / 255.0, x_test.reshape(-1, 28 * 28) / 255.0

    model = create_model()

    model.fit(x_train, y_train, epochs=5, callbacks=[cp_callback])
    return TRAIN_STRING


if __name__ == '__main__':
    app.run('0.0.0.0')
